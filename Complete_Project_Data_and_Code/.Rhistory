# A1. 读取与预处理（相对丰度；可选稀释）
library(tidyverse); library(vegan)
setwd("E:/我的/蔡金秀论文/榆树根系/断根组数据")
asv <- read.csv("Feature Table.csv", check.names = FALSE)
meta <- read.csv("Sample Metadata.csv")
stopifnot("SampleID" %in% names(meta), "Group" %in% names(meta))
# 行名 = ASV，矩阵列名与 metadata 对齐
rownames(asv) <- asv[[1]]; asv <- asv[,-1]
# 读取
asv_raw <- read.csv("Feature Table.csv", check.names = FALSE)
meta    <- read.csv("Sample Metadata.csv", check.names = FALSE)
stopifnot(all(c("SampleID","Group") %in% names(meta)))
# 1) 取出原始 ID 列（假设在第1列；若不是，请把 1 改为实际列序）
id <- asv_raw[[1]]
# 2) 将空白/NA ID 替换为占位前缀，并统一转字符
id <- as.character(id)
id[is.na(id) | trimws(id) == ""] <- "ASV"
# 3) 生成“唯一且稳定”的行名（对重复值自动加后缀 _1, _2, ...）
id_unique <- make.unique(id, sep = "_")
# 4) 设为行名并去掉 ID 列
rownames(asv_raw) <- id_unique
asv_raw <- asv_raw[, -1, drop = FALSE]
# 1) 与元数据对齐（仅保留两边都存在的样本；顺序按元数据）
sample_cols <- intersect(colnames(asv_raw), meta$SampleID)
stopifnot(length(sample_cols) >= 2)
asv_raw   <- asv_raw[, sample_cols, drop = FALSE]
meta_used <- meta[match(sample_cols, meta$SampleID), , drop = FALSE]
# 2) 强制数值化（把 "1,234"、"1e3"、字符数字等都转为数值；无法转换的置为 NA 再按 0 处理）
num_mat <- as.data.frame(lapply(asv_raw, function(x) {
v <- suppressWarnings(as.numeric(gsub(",", "", as.character(x))))
v
}), check.names = FALSE)
rownames(num_mat) <- rownames(asv_raw)
# 3) 将 NA 视作 0（计数/峰面积矩阵常见做法；若你记录了缺失应保留 NA，可改掉此行）
num_mat[is.na(num_mat)] <- 0
# 4) 计算相对丰度（列归一化）；零和样本保护
col_tot <- colSums(num_mat, na.rm = TRUE)
col_tot[col_tot == 0] <- 1
asv_rel <- sweep(num_mat, 2, col_tot, "/")
# 可选：检查是否仍有重复行名（理论上不会）
if (any(duplicated(rownames(asv_rel)))) {
warning("行名仍有重复，请检查 ID 生成逻辑。")
}
# 后续步骤继续用：
#   - 距离矩阵：bc <- vegan::vegdist(t(asv_rel), method = "bray")
#   - PERMANOVA：adonis2(bc ~ Group, data = meta_used, permutations = 999)
#   - PCoA：cmdscale(bc, k=2, eig=TRUE)
#   - α多样性：vegan::estimateR(t(num_mat)) / vegan::diversity(t(num_mat), "shannon")
# 读取
asv_raw <- read.csv("Feature Table.csv", check.names = FALSE)
meta    <- read.csv("Sample Metadata.csv", check.names = FALSE)
stopifnot(all(c("SampleID","Group") %in% names(meta)))
# 1) 取出原始 ID 列（假设在第1列；若不是，请把 1 改为实际列序）
id <- asv_raw[[1]]
# 2) 将空白/NA ID 替换为占位前缀，并统一转字符
id <- as.character(id)
id[is.na(id) | trimws(id) == ""] <- "ASV"
# 3) 生成“唯一且稳定”的行名（对重复值自动加后缀 _1, _2, ...）
id_unique <- make.unique(id, sep = "_")
# 4) 设为行名并去掉 ID 列
rownames(asv_raw) <- id_unique
asv_raw <- asv_raw[, -1, drop = FALSE]
# 1) 与元数据对齐（仅保留两边都存在的样本；顺序按元数据）
sample_cols <- intersect(colnames(asv_raw), meta$SampleID)
stopifnot(length(sample_cols) >= 2)
asv_raw   <- asv_raw[, sample_cols, drop = FALSE]
meta_used <- meta[match(sample_cols, meta$SampleID), , drop = FALSE]
# 2) 强制数值化（把 "1,234"、"1e3"、字符数字等都转为数值；无法转换的置为 NA 再按 0 处理）
num_mat <- as.data.frame(lapply(asv_raw, function(x) {
v <- suppressWarnings(as.numeric(gsub(",", "", as.character(x))))
v
}), check.names = FALSE)
rownames(num_mat) <- rownames(asv_raw)
# 3) 将 NA 视作 0（计数/峰面积矩阵常见做法；若你记录了缺失应保留 NA，可改掉此行）
num_mat[is.na(num_mat)] <- 0
# 4) 计算相对丰度（列归一化）；零和样本保护
col_tot <- colSums(num_mat, na.rm = TRUE)
col_tot[col_tot == 0] <- 1
asv_rel <- sweep(num_mat, 2, col_tot, "/")
